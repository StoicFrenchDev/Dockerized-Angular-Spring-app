{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Docker Spring",
  "steps": [
    {
      "file": "back/Dockerfile",
      "description": "Welcome to the CodeTour for our Dockerfile, which is structured as a multi-stage build for a Java/Spring Boot application.\r\n\r\nThis Dockerfile is designed to streamline the process of building, testing, and deploying our application in a consistent and efficient manner across different environments.\r\n\r\nThroughout this tour, we'll explore each stage of the Dockerfile, including the base setup, development, testing, building, and production stages.\r\n\r\nThe use of a multi-stage build process in this Dockerfile is a best practice in Docker. It allows us to keep our production images as small and secure as possible by separating the build dependencies from the runtime environment.\r\n\r\nOur focus will be on understanding how each stage contributes to the application's lifecycle, from writing code and running tests to packaging and deploying the application in a production environment.\r\n\r\nLet's dive in and explore how each part of this Dockerfile is designed to optimize our development workflow and ensure that our application runs smoothly and reliably in any environment.",
      "line": 1
    },
    {
      "file": "back/Dockerfile",
      "description": "We start our Dockerfile by selecting \"eclipse-temurin:21-jdk\" as our base image.\r\n\r\nThis image contains the Eclipse Temurin JDK, which is an enterprise-grade Java Development Kit.\r\n\r\nThe choice of JDK 21 ensures we have the latest features and security updates.\r\n\r\nThis base image is used for compiling our Java code.",
      "line": 2
    },
    {
      "file": "back/Dockerfile",
      "description": "Here, we set up our working directory inside the container (/workspace/app) and create a volume at /tmp.\r\n\r\nThe working directory is where our application code resides in the container.\r\n\r\nThe volume is used for storing temporary files, which can be beneficial for performance and data persistence.",
      "line": 3
    },
    {
      "file": "back/Dockerfile",
      "description": "These lines handle the copying of our Maven wrapper, Maven configuration, pom.xml, and the src directory into our Docker image.\r\n\r\nThe Maven wrapper (mvnw) allows us to run Maven commands without having Maven installed locally, ensuring consistency across environments.\r\n\r\nCopying pom.xml and the src directory brings our application code and its dependencies into the image.",
      "line": 6
    },
    {
      "file": "back/Dockerfile",
      "description": "The command ./mvnw dependency:resolve is executed to download and resolve all dependencies specified in pom.xml.\r\n\r\nThis step is crucial for compiling the application in later stages.",
      "line": 11
    },
    {
      "file": "back/Dockerfile",
      "description": "This concludes the 'base' stage of our Dockerfile.\r\n\r\nAt this point, we have established a solid foundation for our Java/Spring Boot application. Key actions in this stage include setting up the JDK environment, defining the working directory, copying essential files (like the Maven wrapper and project source code), and resolving dependencies.\r\n\r\nThe purpose of encapsulating these steps in the 'base' stage is to create a common starting point that will be used by all subsequent stages—development, testing, and building. This ensures consistency in the environment across these stages.\r\n\r\nBy resolving dependencies in this stage, we take advantage of Docker's caching mechanisms. Following builds will be faster since dependencies will only be re-downloaded if there are changes in the pom.xml file.\r\n\r\nThe 'base' stage is a crucial part of our Dockerfile, ensuring that our application's build and runtime environments are set up correctly from the very beginning. It lays the groundwork for efficient and reliable application development and deployment.\r\n\r\nWith the base stage complete, we can now move on to the specific stages tailored for development, testing, and building our application.",
      "line": 12
    },
    {
      "file": "back/Dockerfile",
      "description": "The dev stage is specifically configured for the development phase of our application. In this stage, we inherit the environment set up in the base stage, including all dependencies and configurations.\r\n\r\nBy running ./mvnw spring-boot:run, we start the Spring Boot application in development mode. This setup is particularly useful for developers as it supports live reloading—any changes in the source code can be automatically detected and the application is recompiled and restarted, making the development process more efficient and responsive.\r\n\r\nAdditionally, this stage can be configured to include other development-specific tools and settings, such as debuggers or environment-specific variables. It's tailored to provide an environment that closely mirrors production while offering the tools and flexibility needed for effective development.\r\n\r\nThis dev stage emphasizes Docker's role in creating replicable development environments, ensuring that every developer on the team works in a consistent setting, thus minimizing the 'it works on my machine' problem.",
      "line": 14
    },
    {
      "file": "back/Dockerfile",
      "description": "The test stage is dedicated to running automated tests for our application. Similar to the dev stage, it builds on the base stage, ensuring that tests are run in an environment that closely resembles the production setup.\r\n\r\nBy executing ./mvnw test, we run the application’s test suite. This can include unit tests, integration tests, and any other automated tests configured in the Maven project. Running tests in this isolated Docker environment ensures that they are not affected by local machine configurations, leading to more reliable and consistent test results.\r\n\r\nThis stage is particularly valuable in continuous integration pipelines, where automated tests are run in response to code changes. Ensuring that tests pass in this Docker environment is a key step before progressing to the deployment of the application.\r\n\r\nThe separation of the testing environment in its own stage reinforces best practices in software development, where testing is an integral and isolated part of the development process. It helps in catching bugs early and improves the quality of the software.",
      "line": 17
    },
    {
      "file": "back/Dockerfile",
      "description": "As we transition from the development and testing phases to the final stages of our Dockerfile, we enter the phases of building and deploying our application. These next two stages, build and production, are critical in transforming our code into a deployable and runnable form suitable for a production environment.\r\n\r\nThe build stage is where our application takes shape from source code into an executable artifact. This stage is all about compiling the code, ensuring it's properly packaged, and making it ready for deployment. It's a key step in the continuous integration process, ensuring that our application is not only written and tested but also reliably built for deployment.\r\n\r\nFollowing the build process, we move to the production stage. This stage is streamlined for efficiency and security, focusing on creating a minimal and secure environment for running our application. Here, the emphasis shifts from the tools and environments needed for development and testing to those essential for running the application in a real-world scenario.\r\n\r\nThese stages demonstrate Docker's power and flexibility in managing the lifecycle of an application. They encapsulate the principles of immutable infrastructure and infrastructure as code, ensuring that our application is built and run in predictable, repeatable, and secure environments.",
      "line": 19
    },
    {
      "file": "back/Dockerfile",
      "description": "In the build stage, our focus shifts from development and testing to preparing the application for deployment. This stage is responsible for compiling the source code and packaging it into an executable form, typically a JAR file for Java applications.\r\n\r\nThe command ./mvnw package is executed, which performs several key tasks: it compiles the Java code, runs any tests (unless they're explicitly skipped), and then packages the compiled code into a JAR file (Java ARchive). This JAR file  is a self-contained unit that includes your application and any dependencies it needs to run.\r\n\r\nThe significance of this stage lies in its isolation from the rest of the development process. By compartmentalizing the build process, we ensure that the compilation and packaging of the application are done in a clean, controlled environment. \r\n\r\nThis isolation helps in minimizing inconsistencies and potential errors that might arise from differences in development environments.\r\n\r\nThe build stage embodies the practice of continuous integration, where code changes are regularly built and tested, leading to quicker detection of issues and more stable software releases.",
      "line": 21
    },
    {
      "file": "back/Dockerfile",
      "description": "The production stage is the culmination of our Dockerfile, where we prepare the application for deployment in a production environment. This stage is optimized for running the application, focusing on efficiency, security, and stability.\r\n\r\nUnlike the previous stages that used a JDK image, here we switch to a JRE (Java Runtime Environment) image (eclipse-temurin:21-jre-jammy). The JRE is sufficient for running Java applications and is preferred in production due to its smaller size and reduced attack surface.\r\n\r\nWe copy the compiled JAR file from the build stage into this production image. This approach of copying only the necessary executable artifact (the JAR file) into the production image ensures that the final image is as lean as possible. It contains nothing superfluous that could increase the size, complexity, or vulnerability of the production environment.\r\n\r\nThe application is executed with a simple java -jar command. This stage is critical for ensuring that the application runs efficiently and reliably in production, providing the performance and resilience needed for a production-grade deployment.\r\n\r\nThe design of this production stage reflects key principles in Docker and DevOps best practices, focusing on minimalism, security, and consistency across deployment environments.",
      "line": 25
    },
    {
      "file": "back/Dockerfile",
      "description": "We've now completed our tour of the Dockerfile, which is designed for a Java/Spring Boot application using a multi-stage build approach. We've seen how Docker can efficiently manage different aspects of the application lifecycle—from development and testing to building and running the application in production.\r\n\r\nRecap of Stages:\r\n    Base Stage: Set up the foundational environment, including JDK and dependencies.\r\n\r\n    Development Stage (‘dev’): Focused on providing a dynamic environment for development, with features like live reloading.\r\n\r\n    Testing Stage (‘test’): Dedicated to running automated tests, ensuring code quality and stability.\r\n\r\n    Build Stage (‘build’): Compiled and packaged the application into a JAR file, ready for deployment.\r\n\r\n    Production Stage (‘production’): Created a minimal and secure runtime environment, emphasizing efficiency and security for production deployment.\r\n\r\nThis Dockerfile comports best practices in software development and deployment, using Docker's strengths in creating reproducible, consistent, and isolated environments. The separation of concerns across different stages ensures that each stage is optimized for its specific purpose, contributing to a robust, scalable, and maintainable development pipeline.",
      "line": 26
    }
  ],
  "ref": "code-tour"
}