{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Docker Angular",
  "steps": [
    {
      "file": "frontend/Dockerfile",
      "description": "Welcome to a detailed CodeTour of our Angular application's Dockerfile. \r\n\r\nJust like the dockerfile for Spring, this file is crafted with a multi-stage build process to cater to both development and production needs. \r\n\r\nAs always the key philosophy is to create separate environments for building, developing, and serving the application, ensuring each stage is optimized for its specific purpose. In this tour, we'll delve into each stage's role, understanding how Docker aids in efficient Angular application development and deployment.",
      "line": 1
    },
    {
      "file": "frontend/Dockerfile",
      "description": "Our Dockerfile begins with the node:18-alpine image, chosen for its small size and efficiency.\r\n\r\nAlpine Linux provides a minimalistic base, reducing overhead and potential security vulnerabilities.\r\n\r\nThis stage sets the groundwork for the Angular app build process, highlighting Docker's ability to standardize development environments. We're establishing a reliable and consistent base, ensuring that the build process is reproducible and independent of individual development machines.",
      "line": 2
    },
    {
      "file": "frontend/Dockerfile",
      "description": "In this step, we're establishing the foundational setup for the Docker container in which our Angular application will be built.\r\n\r\nThe WORKDIR /usr/src/app command is crucial as it creates and sets the /usr/src/app directory as the working directory inside the Docker container. All subsequent Dockerfile commands will operate within this directory.\r\n\r\nThis is where our application's source code, along with its dependencies, will reside in the container. The choice of /usr/src/app as the directory is a common convention in Docker setups for Node.js applications, but it can be any directory as per the developer's preference.",
      "line": 3
    },
    {
      "file": "frontend/Dockerfile",
      "description": "We then introduce a build argument with ARG CONFIGURATION. The ARG instruction defines a variable that users can pass at build time to the Docker builder. This variable CONFIGURATION is used to control how the Angular application is built. \r\n\r\nFor instance, in Angular, you might have different build configurations for different environments like development, staging, or production, each with its own set of optimizations and settings. By using an ARG, we provide flexibility and control over these configurations.\r\n\r\nFor example, when building the Docker image, you can specify the configuration by adding --build-arg CONFIGURATION=production to the Docker build command (that is if we set different configurations). This approach enhances the flexibility of our Docker build process, allowing us to tailor the Angular build according to specific requirements or environments.",
      "line": 4
    },
    {
      "file": "frontend/Dockerfile",
      "description": "The inclusion of WORKDIR and ARG in this stage of the Dockerfile is a demonstration of Docker's ability to create highly configurable and standardized build environments.\r\n\r\nIt ensures that no matter where or how the Docker image is built, it will always have a consistent directory structure and the ability to adjust build parameters as needed.\r\n\r\nThis setup plays a key role in the portability and flexibility of Docker.",
      "line": 5
    },
    {
      "file": "frontend/Dockerfile",
      "description": "This step is a critical part of the Dockerfile where we handle the Angular application's dependencies. It begins with copying the package.json and package-lock.json files into our Docker container. These two files are key to Node.js and Angular projects:\r\n\r\n    package.json: This file lists all the dependencies that our Angular application needs. It specifies various packages and their respective versions that the application requires to run and build. This file also includes scripts and metadata relevant to the application.\r\n\r\n    package-lock.json: This file is automatically generated and is intended to track the exact versions of each dependency that were installed. It ensures that the same versions of the dependencies are installed each time you run npm install, providing consistency across installations.",
      "line": 6
    },
    {
      "file": "frontend/Dockerfile",
      "description": "The following RUN command in the Dockerfile is where the actual installation of these dependencies happens.\r\n\r\nHere, we utilize a Docker feature known as a cache mount, indicated by --mount=type=cache,target=/usr/src/app/.npm.\r\n\r\nCache mounts in Docker are used to preserve a directory between builds. In our case, we're preserving the .npm directory where npm stores its cache. By caching the downloaded npm packages, subsequent builds can reuse these cached packages instead of downloading them again, which significantly speeds up the build process.",
      "line": 8
    },
    {
      "file": "frontend/Dockerfile",
      "description": "NPM Cache Configuration: The command npm set cache /usr/src/app/.npm points npm to use our cache mount as its cache directory.\r\n\r\nThis step is crucial for aligning npm with Dockerâ€™s caching mechanism.",
      "line": 9
    },
    {
      "file": "frontend/Dockerfile",
      "description": "Dependency Installation: The npm install command looks at package.json and installs the dependencies listed there.\r\n\r\nSince we've set up caching, if the dependencies haven't changed from a previous build, npm will fetch them from the cache, making this process much faster.",
      "line": 10
    },
    {
      "file": "frontend/Dockerfile",
      "description": "The final part of this command, npm install -g @angular/cli, installs the Angular CLI globally within the Docker image.\r\n\r\nAngular CLI is a command-line interface tool used to create, manage, build, and test Angular applications.\r\n\r\nInstalling it globally within the image ensures that it's available for use in subsequent steps, like building or serving the application.",
      "line": 11
    },
    {
      "file": "frontend/Dockerfile",
      "description": "This step in the Dockerfile, COPY . ., is pivotal in the process of building your Angular application within the Docker environment. The command performs a seemingly simple yet crucial action: copying the application's source code from your project directory (on the host machine) into the Docker container.\r\n\r\nThe first . in the command represents the source path on the host machine. In this context, it means 'copy everything in the current directory where the Docker build command is being executed'. This includes all the Angular project files - your source code, components, modules, static assets, and other necessary files.\r\n\r\nThe second . in the command specifies the destination path inside the Docker container. Since we previously set the working directory to /usr/src/app with the WORKDIR command, this . refers to that directory. Thus, the command copies all the contents from your project directory into /usr/src/app inside the container.\r\n\r\nBy copying the entire project into the Docker container, we ensure that all the necessary code and resources are available for the subsequent build process.\r\n\r\nThis step is fundamental in creating a complete environment within the container that mirrors your project's structure on the host machine. It sets the stage for an isolated and consistent build process, a key advantage of using Docker for application development.",
      "line": 13
    },
    {
      "file": "frontend/Dockerfile",
      "description": "Following the copying of the project files into the container, the Dockerfile executes RUN npm run build --configuration=\"$CONFIGURATION\".\r\n\r\nThis command triggers the build process of the Angular application inside the Docker container.\r\n\r\nThe npm run build part of the command refers to an npm script defined in package.json. This script typically calls the Angular CLI command ng build, which compiles the Angular application into an output directory named dist/ at the root of the workspace.\r\n\r\nThe compilation includes transforming the TypeScript code into JavaScript, optimizing the code, and bundling it along with HTML and CSS.\r\n\r\nThe --configuration=\"$CONFIGURATION\" portion allows for specifying a build configuration. Build configurations in Angular can define specific compiler options, environment variables, and other settings suitable for different environments (e.g., development, staging, production).\r\n\r\nThis step is critical in Docker's workflow as it encapsulates the process of compiling the Angular application within the container environment.\r\n\r\nBy doing so, Docker ensures that the build is consistent and repeatable, regardless of the developer's local environment. This eliminates the 'it works on my machine' problem and aligns with best practices in continuous integration and deployment.",
      "line": 15
    },
    {
      "file": "frontend/Dockerfile",
      "description": "In the dev stage, defined by FROM build AS dev, we set up an environment specifically for development.\r\n\r\nThis stage inherits all the settings and installed packages from the build stage. The critical command here is CMD [\"ng\", \"serve\", \"--host\", \"0.0.0.0\"], which does the following:\r\n\r\n    ng serve: This command launches the Angular development server. It serves the application, supports hot reloading (automatically reloading the application in the browser as you modify the code), and provides a development-friendly environment with debugging capabilities.\r\n\r\n    --host \"0.0.0.0\": This option configures the Angular development server to listen on all network interfaces inside the container. It's crucial for accessing the Angular application from outside the Docker container, such as your development machine's browser.",
      "line": 18
    },
    {
      "file": "frontend/Dockerfile",
      "description": "The prod stage, starting with FROM nginx:1.21-alpine AS prod, is where we configure the Docker container to serve the Angular application in a production environment.\r\n\r\nSome extra details from the doc on the choice of this image:\r\n\r\nnginx:1.21-alpine is a Docker image that combines two key components: Nginx and Alpine Linux. Here's a brief overview of each:\r\n\r\n    Nginx is a popular, high-performance web server known for its efficiency, handling large numbers of simultaneous connections with a low memory footprint.\r\n    Beyond serving static content, Nginx is often used as a reverse proxy and load balancer, providing additional flexibility in how web applications are deployed and managed.\r\n\r\n    Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc (a standard library in C) and BusyBox.\r\n    Its small size and minimal design make it ideal for use in containers.\r\n    Due to its minimalistic nature, Alpine Linux comes with fewer pre-installed packages and services, reducing the potential attack surface of the container.\r\n    Containers based on Alpine Linux are known for their quick startup times and efficient use of resources, making them well-suited for high-performance applications.\r\n\r\nWhen combined in the nginx:1.21-alpine Docker image:\r\n\r\nYou get an efficient, secure, and lightweight container ideal for deploying web applications, especially suitable for serving static content like a compiled Angular application.\r\nThe image benefits from Nginx's powerful web serving and proxying capabilities, along with the reduced size and security features of Alpine Linux. This combination makes it a popular choice for production environments in Dockerized applications.",
      "line": 20
    },
    {
      "file": "frontend/Dockerfile",
      "description": "COPY --link nginx.conf /etc/nginx/conf.d/default.conf\r\n\r\nThis command places a custom Nginx configuration file into the container. \r\n\r\nThe --link flag helps optimize Docker caching, particularly useful if you change the base image but not the configuration file.",
      "line": 23
    },
    {
      "file": "frontend/Dockerfile",
      "description": "COPY --link --from=build /usr/src/app/dist/angular-front /usr/share/nginx/html\r\n\r\nThis step copies the compiled Angular application (from the dist/ directory created in the build stage) into the Nginx server's directory.\r\n\r\nIt ensures that Nginx serves the Angular application when the container is run.",
      "line": 25
    },
    {
      "file": "frontend/Dockerfile",
      "description": "EXPOSE 4200\r\n\r\nThis line indicates that the container listens on port 4200. \r\n\r\nWhile EXPOSE does not publish the port by itself, it functions as documentation and is used by Docker to understand which port the application should be available on.",
      "line": 27
    },
    {
      "file": "frontend/Dockerfile",
      "description": "This brings us to the end of our detailed CodeTour of the Angular application Dockerfile.\r\n\r\nThroughout this tour, we've explored how each instruction and stage in the Dockerfile plays a specific role in preparing, building, and deploying the Angular application in both development and production environments.\r\n\r\nStarting with setting up the Node.js environment, managing dependencies, and compiling the application, we've seen how Docker creates a consistent and controlled build process. This is crucial for ensuring that the application behaves the same way across different environments, eliminating the common 'it works on my machine' problem.\r\n\r\nThe multi-stage build process, encompassing development and production stages, illustrates flexibility of Docker. It allows us to tailor the container's environment to the specific needs of each stage. Using Node.js and the Angular CLI in the development stage for live reloading and testing, and transitioning to a lightweight, efficient Nginx server in the production stage for serving the static content.",
      "line": 28
    }
  ],
  "ref": "code-tour"
}